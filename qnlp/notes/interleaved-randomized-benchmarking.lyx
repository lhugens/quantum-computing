#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{indentfirst}
\usepackage{mathtools}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
theorems-chap
\end_modules
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing double
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 2cm
\rightmargin 1cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style british
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Paper reviews - 
\end_layout

\begin_layout Section
Efficient measurement of quantum gate error by interleaved randomized benchmarki
ng 
\end_layout

\begin_layout Standard
We describe a scalable experimental protocol for estimating the average
 error of individual quantum computational gates
\end_layout

\begin_layout Standard
The protocol consists of interleaving random Clifford gates between the
 gate of interest and provides an estimate as well as theoretical bounds
 for the average error of the gate under test.
\end_layout

\begin_layout Standard
Standard method for characterizing a quantum operation is quantum process
 tomography (QPT), but it has two drawbacks:
\end_layout

\begin_layout Enumerate
is not scalable in number of qubits
\end_layout

\begin_layout Enumerate
if state-preparation and measurement (SPAM) errors are present, they will
 contribute to those of the gate of interest, hence giving unfaithful estimation
 of the actual error.
\end_layout

\begin_layout Standard
A method that provides both scalability and faithful measure of noise independen
tly of SPAM errors is randomized benchmarking RB.
 It's general idea is to create random sequences of gates that compose the
 identity operation, and measure the fidelity of each sequence.
\end_layout

\begin_layout Standard
In this paper we present a new protocol for benchmarking individual Clifford
 gates via randomization.
\end_layout

\begin_layout Standard

\series bold
Why is studying Clifford gates rather than general gates not a significant
 restriction?
\series default
 Because any unitary gate can be implemented with fault-tolerance using
 special input states, Clifford elements and computation basis measurements
 (ref 21).
 Additionally, the unitary group can be generated via the Clifford group
 through the addition of a single gate not in the group.
\end_layout

\begin_layout Standard

\series bold
What is the Clifford group? 
\series default
The group generated by three gates, Hadamard, CNOT and S.
\end_layout

\begin_layout Section
Fault-Tolerant Quantum Computation
\end_layout

\begin_layout Standard
Two difficulties in realizing quantum computation:
\end_layout

\begin_layout Enumerate
decoherence tends to destroy the information in a superposition of states
 in a quantum computer, making long computations impossible.
\end_layout

\begin_layout Enumerate
inaccuracies in quantum state transformations throughout te computation
 accumulate, rendering long computations unreliable.
\end_layout

\begin_layout Standard
Main result of the paper:
\end_layout

\begin_layout Itemize
For any quantum computation with 
\begin_inset Formula $t$
\end_inset

 gates, we show how to build a polunomial size quantum circuit that tolerates
 
\begin_inset Formula $\mathcal{O}\left(1/\log^{c}t\right)$
\end_inset

 amounts of inaccuracy and decoherence per gate, for some constant 
\begin_inset Formula $c$
\end_inset

.
 We do this by showing that operations can be performed on quantum data
 encoded by quantum error-correcting codes without decoding this data.
\end_layout

\begin_layout Subsection*
Introduction 
\end_layout

\begin_layout Standard
[26, 23, 25] - quantum algs.
 to solve probs in polynomial time that turing machines only can in exponential
 time
\end_layout

\begin_layout Standard
[16, 28, 12] - 
\emph on
decoherence
\emph default
: quantum superpositions are quite fragile and decay easily, one way to
 think about it is that the environment is 
\begin_inset Quotes bld
\end_inset

measuring
\begin_inset Quotes brd
\end_inset

 the system by interacting with it [31]
\end_layout

\begin_layout Standard
[16, 9, 4] - 
\emph on
inaccuracy
\emph default
: for example, the gate that rotates a state by 
\begin_inset Formula $\theta$
\end_inset

 will be of course implemented in some analog way that yields an inaccuracy
 in this angle
\end_layout

\begin_layout Standard
[24, 11, 27, 15, 7] - quantum correcting codes that can reduce both decoherence
 and inaccuracy dramatically during transmission and storage of quantum
 data.
 Now we build upon them to show that their use can also reduce these problems
 while performing computations.
\end_layout

\begin_layout Standard
For any polynomial size qc, we show how to construct a fault-tolerant version
 of the quantum circuit which computes the same function and also has polynomial
 size.
 We use the quantum circuit model augmented with measurement operations
 during the computation.
\end_layout

\begin_layout Standard
The techniques used in this paper to build fault tolerant quantum circuits
 rely heavily on quantum error correcting codes [24, 11, 27, 15, 7].
 These codes can be used to encode 
\begin_inset Formula $k$
\end_inset

 qubits of data into 
\begin_inset Formula $n$
\end_inset

 qubits so as to protect the data if errors occur in any 
\begin_inset Formula $t$
\end_inset

 of these 
\begin_inset Formula $n$
\end_inset

 qubits.
 The values of 
\begin_inset Formula $k,t$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

 depend on the code used, and 
\begin_inset Formula $t$
\end_inset

 cannot exceed some upper bound depending on 
\begin_inset Formula $n$
\end_inset

 and 
\begin_inset Formula $k$
\end_inset

, analogous to upper bounds in classical information theory.
 
\end_layout

\begin_layout Standard
This paper shows both how to correct errors in encoded qubits using noisy
 gates and also how to compute on these encoded qubits without ever decoding
 the qubits.
 We can thus alternate steps which perform computations on encoded qubits
 with steps that correct any errors that have occurred during the computation.
\end_layout

\begin_layout Subsection*
Error-correcting codes
\end_layout

\begin_layout Enumerate
We only consider vectors and codes over 
\begin_inset Formula $F_{2}$
\end_inset

, the field of two elements, so 1+1=0
\end_layout

\begin_layout Enumerate
The 
\emph on
Hamming weight 
\begin_inset Formula $d$
\end_inset

 
\emph default
is the number of 1's in a bit vector.
\end_layout

\begin_layout Enumerate
The 
\emph on
Hamming distance 
\begin_inset Formula $d_{H}\left(v,w\right)$
\end_inset

 
\emph default
is the Hamming weight of 
\begin_inset Formula $v+w$
\end_inset

.
 e.g.
 
\begin_inset Formula $d_{H}\left(001,011\right)=d\left(010\right)=1$
\end_inset


\end_layout

\begin_layout Enumerate
A code 
\begin_inset Formula $\mathcal{C}$
\end_inset

 of length 
\begin_inset Formula $n$
\end_inset

 is a set of binary vectors of length 
\begin_inset Formula $n$
\end_inset

, called 
\emph on
codewords.
\end_layout

\begin_layout Enumerate
In a 
\emph on
linear code 
\emph default
the codewords are those vectors in a subspace of 
\begin_inset Formula $F_{2}^{n}$
\end_inset

.
\end_layout

\begin_layout Enumerate
The 
\emph on
minimum distance 
\begin_inset Formula $d=d\left(\mathcal{C}\right)$
\end_inset

 
\emph default
of a binary code 
\begin_inset Formula $\mathcal{C}$
\end_inset

 is the minimum distance between two distinct codewords.
 If the code is linear, the minimum distance is just the minimum Hamming
 weight of a nonzero codeword.
\end_layout

\begin_layout Enumerate
A linear code 
\begin_inset Formula $\mathcal{C}$
\end_inset

 with length 
\begin_inset Formula $n$
\end_inset

, dimension 
\begin_inset Formula $k$
\end_inset

 and minimum weight 
\begin_inset Formula $d$
\end_inset

 is called an 
\begin_inset Formula $\left[n,k,d\right]$
\end_inset

 code.
\end_layout

\begin_layout Enumerate
A generator 
\begin_inset Formula $G$
\end_inset

 for a code is an 
\begin_inset Formula $n\times k$
\end_inset

 matrix whose rows are its codewords.
 
\end_layout

\begin_layout Enumerate
A parity check matrix 
\begin_inset Formula $H$
\end_inset

 for this code is an 
\begin_inset Formula $n$
\end_inset

 by 
\begin_inset Formula $n-k$
\end_inset

 matrix such that 
\begin_inset Formula $Hx^{T}=0$
\end_inset

 for any codeword 
\begin_inset Formula $x$
\end_inset

.
 In other words, the row space of 
\begin_inset Formula $H$
\end_inset

 is the subspace of 
\begin_inset Formula $F_{2}$
\end_inset

 perpendicular to 
\begin_inset Formula $\mathcal{C}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Suppose we know a vector 
\begin_inset Formula $y$
\end_inset

 which is a codeword with 
\begin_inset Formula $t$
\end_inset

 or fewer errors.
 All the information needed to correct 
\begin_inset Formula $y$
\end_inset

 is contained in the 
\emph on
syndrome 
\emph default
vector 
\begin_inset Formula $s=Hy^{T}$
\end_inset

.
 If the syndrome is 0, we know 
\begin_inset Formula $y\in\mathcal{C}$
\end_inset

, otherwise we can deduce the positions of the errors from the syndrome,
 and correct them by applying NOT gates to the erroneous bits.
 Computing the positions of the errors from the syndrome is in general a
 hard problem, but for many codes it can be done in polynomial time.
\end_layout

\begin_layout Enumerate
The dual code 
\begin_inset Formula $\mathcal{C}^{\perp}$
\end_inset

 is the set of vectors perpendicular to all codewords, that is 
\begin_inset Formula $\mathcal{C}^{\perp}=\left\{ v\in F_{2}:v\cdot c=0\,\forall c\in\mathcal{C}\right\} $
\end_inset

.
 It follows that 
\begin_inset Formula $G$
\end_inset

 is a generator of it and 
\begin_inset Formula $H$
\end_inset

 a parity check matrix for it.
\end_layout

\begin_layout Enumerate
We can use 
\begin_inset Formula $\mathcal{C}$
\end_inset

 to generate a quantum error correcting code which will correct errors in
 any 
\begin_inset Formula $t=\frac{d-1}{2}$
\end_inset

 or fewer qubits.
\end_layout

\begin_layout Enumerate
Suppose that 
\begin_inset Formula $v\in\mathcal{C}$
\end_inset

, then
\begin_inset Formula 
\[
\left|s_{v}\right\rangle =2^{-(n-k)/2}\sum_{w\in\mathcal{C}^{\perp}}|v+w\rangle
\]

\end_inset

this is called the 
\begin_inset Formula $s$
\end_inset

-basis.
 It can shown that 
\begin_inset Formula 
\[
\left|s_{v}\right\rangle =\left|s_{u}\right\rangle \iff u+v\in\mathcal{C}^{\perp}
\]

\end_inset

Thus, there are 
\begin_inset Formula $\dim\mathcal{C}-\dim\mathcal{C}^{\perp}=2k-n$
\end_inset

 codewords in our quantum code.
\end_layout

\begin_layout Enumerate
By rotating each of the 
\begin_inset Formula $n$
\end_inset

 qubits if a quantum codeword like
\begin_inset Formula 
\[
\begin{aligned} & |0\rangle\rightarrow\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)\\
 & |1\rangle\rightarrow\frac{1}{\sqrt{2}}(|0\rangle-|1\rangle)
\end{aligned}
\]

\end_inset

it is easy to verify that we obtain
\begin_inset Formula 
\[
\left|c_{v}\right\rangle =2^{-k/2}\sum_{w\in\mathcal{C}}(-1)^{v\cdot w}|w\rangle
\]

\end_inset

this is the 
\begin_inset Formula $c$
\end_inset

-basis for our code.
 It also has the property 
\begin_inset Formula $\left|c_{v}\right\rangle =\left|c_{u}\right\rangle \iff u+v\in\mathcal{C}^{\perp}$
\end_inset

.
\end_layout

\begin_layout Enumerate
In quantum codes, in order to correct 
\begin_inset Formula $t$
\end_inset

 arbitrary errors, all that is needed is be able to correct any 
\begin_inset Formula $t$
\end_inset

 errors of the following types: bit errors 
\begin_inset Formula $\left\{ \left\vert 0\right\rangle \rightarrow\left\vert 1\right\rangle ,\left\vert 1\right\rangle \rightarrow\left\vert 0\right\rangle \right\} $
\end_inset

, phase errors 
\begin_inset Formula $\left\{ \left\vert 0\right\rangle \rightarrow\left\vert 0\right\rangle ,\left\vert 1\right\rangle \rightarrow-\left\vert 1\right\rangle \right\} $
\end_inset

 and bit-phase errors 
\begin_inset Formula $\left\{ \left\vert 0\right\rangle \rightarrow\left\vert 1\right\rangle ,\left\vert 1\right\rangle \rightarrow-\left\vert 0\right\rangle \right\} $
\end_inset

.
\end_layout

\begin_layout Subsection*
Correcting errors fault-tolerantly
\end_layout

\begin_layout Enumerate
To correct errors, we first correct bit errors by classical techniques in
 the 
\begin_inset Formula $s$
\end_inset

-basis, then change to the 
\begin_inset Formula $c$
\end_inset

-basis, (phase errors in 
\begin_inset Formula $s$
\end_inset

-basis become bit errors in the 
\begin_inset Formula $c$
\end_inset

-basis) and perform the same classical techniques again.
\end_layout

\begin_layout Enumerate
The error correction can be done by determining which bits are in error
 by first computing the (classical) syndrome and then NOTting the bits in
 errors.
 The hard part is to determine which bits are in error.
\end_layout

\begin_layout Enumerate
An obvious way to do this would be to have an ancilla qubit for each qubit
 in the code, and a CNOT gate between each of these pairs, such that measuring
 the ancilla bits would tell us exactly which bits are in error, and we
 could then NOT those.
 However, this is not robust against errors, 
\end_layout

\end_body
\end_document
